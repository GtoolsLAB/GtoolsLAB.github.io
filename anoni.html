<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glitch Fullscreen</title>
  <style>
    /* Reset básico */
    html,body{height:100%;margin:0}
    body{background:#000;overflow:hidden;display:flex;align-items:center;justify-content:center}

    /* Contenedor centrado sin otros objetos */
    .wrap{position:relative;width:clamp(200px,60vmin,900px);height:auto;display:block}
    img{display:block;width:100%;height:auto;max-height:90vh;object-fit:contain}

    /* Efecto glitch creado con duplicados pseudo-elementos */
    .glitch{position:relative;filter:drop-shadow(0 0 8px rgba(0,0,0,.6));}
    .glitch::before,
    .glitch::after{
      content:"";
      position:absolute;inset:0;pointer-events:none;background-repeat:no-repeat;background-position:center;background-size:contain;mix-blend-mode:screen;opacity:.9;
      background-image:inherit; /* será sustituido por JS para usar la misma src */
    }

    /* Animaciones */
    @keyframes glitch-scan {
      0%{transform:translateX(0)}
      20%{transform:translateX(-6px)}
      40%{transform:translateX(4px)}
      60%{transform:translateX(-2px)}
      80%{transform:translateX(2px)}
      100%{transform:translateX(0)}
    }

    @keyframes glitch-shift {
      0%{clip-path:inset(0 0 0 0)}
      10%{clip-path:inset(10% 0 75% 0)}
      20%{clip-path:inset(75% 0 10% 0)}
      30%{clip-path:inset(20% 0 60% 0)}
      40%{clip-path:inset(60% 0 20% 0)}
      50%{clip-path:inset(0 0 0 0)}
      100%{clip-path:inset(0 0 0 0)}
    }

    .glitch::before{animation:glitch-scan 2.6s infinite linear;transform:translateX(0);filter:hue-rotate(-10deg) contrast(1.05) saturate(1.1);mix-blend-mode:screen}
    .glitch::after{animation:glitch-shift 3.2s infinite linear;transform:translateX(0);filter:hue-rotate(20deg) contrast(1.1) saturate(1.2);mix-blend-mode:overlay;opacity:.85}

    /* Pequeños saltos "scanlines" con pseudo elemento interno */
    .scanline{
      position:absolute;inset:0;pointer-events:none;background-image:linear-gradient(rgba(255,255,255,0.02) 50%, rgba(0,0,0,0) 50%);background-size:100% 3px;mix-blend-mode:overlay;opacity:0.4;animation:scan-move 0.6s infinite linear
    }
    @keyframes scan-move{from{background-position:0 0}to{background-position:0 6px}}

    /* Asegura que no haya foco visible, nada más en la página */
    :focus{outline:none}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Reemplaza "imagen.jpg" por la ruta de tu imagen. No hay otros elementos en la página. -->
    <div class="glitch" id="glitch">
      <img id="mainImg" src="imagen.jpg" alt="" draggable="false">
      <div class="scanline" aria-hidden="true"></div>
    </div>
  </div>

  <script>
    // Intento de fullscreen al cargar — algunos navegadores bloquean el fullscreen automático;
    // por eso también intentamos de nuevo en el primer gesto del usuario.
    function tryFullscreen(){
      const el = document.documentElement;
      if (document.fullscreenElement) return;
      if (el.requestFullscreen) {
        el.requestFullscreen().catch(()=>{});
      } else if (el.webkitRequestFullscreen) { /* Safari */
        el.webkitRequestFullscreen();
      }
    }

    window.addEventListener('load', ()=>{
      // Intento inmediato
      tryFullscreen();

      // Hacemos que los pseudo-elementos usen la misma imagen (no se puede enlazar background-image a <img> en CSS directamente)
      const img = document.getElementById('mainImg');
      const glitch = document.getElementById('glitch');
      function syncBackgrounds(){
        const src = img.getAttribute('src');
        glitch.style.backgroundImage = `url('${src}')`;
        glitch.style.backgroundRepeat = 'no-repeat';
        glitch.style.backgroundPosition = 'center';
        glitch.style.backgroundSize = 'contain';
        // también lo aplicamos a los pseudo elementes mediante una propiedad CSS custom
        glitch.style.setProperty('--img-src', `url('${src}')`);
        // Los pseudo ::before/::after usan background-image:inherit, así que al definirlo en el elemento funciona.
      }
      if (img.complete) syncBackgrounds();
      img.addEventListener('load', syncBackgrounds);

      // Si el intento automático falla por la política del navegador, solicitamos fullscreen al primer gesto del usuario
      document.addEventListener('pointerdown', function onFirstGesture(){
        tryFullscreen();
        document.removeEventListener('pointerdown', onFirstGesture);
      });
    });

    // Previene que la imagen se pueda arrastrar o abrir contexto accidentalmente
    document.addEventListener('dragstart', e=>e.preventDefault());
    document.addEventListener('contextmenu', e=>e.preventDefault());
  </script>
</body>
</html>
